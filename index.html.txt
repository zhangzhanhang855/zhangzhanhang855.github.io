<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>PIXEL POKER: THE FULL ARSENAL</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg: #0d0d15;
            --pixel-gold: #ffcf00;
            --pixel-red: #ff3333;
            --pixel-white: #f0f0f0;
        }

        body {
            margin: 0; background-color: var(--bg);
            font-family: 'Press Start 2P', cursive;
            color: white; image-rendering: pixelated; overflow: hidden;
            transition: background 0.1s;
        }

        /* 炸弹特效 */
        @keyframes shockwave {
            0% { transform: scale(1); filter: brightness(1); }
            20% { transform: scale(1.2); filter: brightness(5) invert(1); }
            100% { transform: scale(1); filter: brightness(1); }
        }
        .bomb-effect { animation: shockwave 0.6s steps(4) forwards; }
        
        @keyframes bg-glitch {
            0%, 40% { background: #ff0000; }
            20%, 60% { background: #000; }
            100% { background: var(--bg); }
        }
        .glitch-bg { animation: bg-glitch 0.4s steps(2); }

        #stage { height: 100vh; display: flex; flex-direction: column; padding: 30px; box-sizing: border-box; }

        #ui-top {
            display: flex; justify-content: space-between; align-items: center;
            padding: 15px; border: 4px solid var(--pixel-white); background: #1a1a2e;
        }

        .hand-area { display: flex; justify-content: center; align-items: center; min-height: 160px; position: relative; }
        
        .card {
            width: 75px; height: 105px; background: var(--pixel-white);
            color: #000; border: 4px solid #000; margin-left: -40px;
            display: flex; flex-direction: column; padding: 8px; box-sizing: border-box;
            cursor: pointer; position: relative; box-shadow: 4px 4px 0px rgba(0,0,0,0.8);
            transition: top 0.2s;
        }
        .card.selected { transform: translateY(-40px) !important; border-color: var(--pixel-gold); z-index: 100 !important; }
        .card.back { background: #2244aa; border-color: #fff; }
        .card.red { color: var(--pixel-red); }
        .card .v { font-size: 14px; line-height: 1; }

        #desk { flex: 1; margin: 20px 0; border: 4px solid #222; display: flex; flex-direction: column; justify-content: center; align-items: center; }

        .controls { display: flex; justify-content: center; gap: 20px; height: 60px; visibility: hidden; }
        .controls.active { visibility: visible; }

        button {
            padding: 12px 24px; background: #fff; border: 4px solid #000;
            font-family: inherit; font-size: 10px; cursor: pointer;
            box-shadow: 4px 4px 0px var(--pixel-gold);
        }
        button:active { transform: translate(3px, 3px); box-shadow: none; }
        .critical { color: var(--pixel-red); animation: pulse 0.2s infinite; }
        @keyframes pulse { 50% { opacity: 0; } }
    </style>
</head>
<body>

<div id="stage">
    <div id="ui-top">
        <div>CPU:<span id="comp-count">0</span></div>
        <div id="timer">30</div>
        <button onclick="initGame()">REBOOT</button>
    </div>

    <div id="hand-1" class="hand-area"></div>

    <div id="desk">
        <div id="desk-1" class="hand-area"></div>
        <div id="desk-0" class="hand-area"></div>
    </div>

    <div class="controls" id="ui">
        <button onclick="handlePlay()">EXECUTE</button>
        <button onclick="handlePass()">SKIP</button>
    </div>

    <div id="hand-0" class="hand-area"></div>
</div>

<script>
/** --- 音效合成 --- **/
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    if(type==='select'){ osc.type='square'; osc.frequency.setValueAtTime(600,now); gain.gain.setValueAtTime(0.05,now); osc.start(); osc.stop(now+0.05); }
    else if(type==='play'){ osc.type='triangle'; osc.frequency.setValueAtTime(300,now); osc.frequency.exponentialRampToValueAtTime(50,now+0.2); gain.gain.setValueAtTime(0.2,now); osc.start(); osc.stop(now+0.2); }
    else if(type==='bomb'){ 
        osc.type='sawtooth'; osc.frequency.setValueAtTime(100,now); osc.frequency.linearRampToValueAtTime(20,now+0.5);
        gain.gain.setValueAtTime(0.3,now); gain.gain.linearRampToValueAtTime(0,now+0.5); osc.start(); osc.stop(now+0.5);
    }
}

/** --- 全牌型逻辑引擎 --- **/
const POWER = { '3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'10':10,'J':11,'Q':12,'K':13,'A':14,'2':15,'S':16,'B':17 };
let G = { hands: [[], []], last: null, turn: 0, selected: new Set(), timeLeft: 30, timerInt: null };

function getInfo(cards) {
    if(!cards.length) return null;
    let counts = {}; cards.forEach(c => counts[c.p] = (counts[c.p] || 0) + 1);
    let vals = Object.entries(counts).map(e=>({p:Number(e[0]), c:e[1]})).sort((a,b)=>b.c-a.c || a.p-b.p);
    let len = cards.length;
    let m = vals[0];

    // 1. 炸弹
    if(m.c === 4 && len === 4) return { type: 'bomb', p: m.p, len: 4, weight: 800+m.p };
    if(len === 2 && cards[0].p >= 16 && cards[1].p >= 16) return { type: 'bomb', p: 99, len: 2, weight: 1000 };

    // 2. 单/双/三
    if(len === 1) return { type: 'single', p: m.p, len: 1 };
    if(len === 2 && m.c === 2) return { type: 'pair', p: m.p, len: 2 };
    if(len === 3 && m.c === 3) return { type: 'trio', p: m.p, len: 3 };

    // 3. 三带一/二
    if(len === 4 && m.c === 3) return { type: 'trio_1', p: m.p, len: 4 };
    if(len === 5 && m.c === 3 && vals[1].c === 2) return { type: 'trio_2', p: m.p, len: 5 };

    // 4. 顺子/连对/飞机
    let ps = vals.map(v => v.p).sort((a,b)=>a-b);
    let isCont = ps[ps.length-1] < 15 && ps[ps.length-1]-ps[0] === ps.length-1;
    if(len >= 5 && vals.every(v => v.c === 1) && isCont) return { type: 'straight', p: ps[0], len };
    if(len >= 6 && len%2===0 && vals.every(v => v.c === 2) && isCont) return { type: 'double_straight', p: ps[0], len };
    if(len >= 6 && len%3===0 && vals.every(v => v.c === 3) && isCont) return { type: 'airplane', p: ps[0], len };

    // 5. 四带二
    if(len === 6 && m.c === 4) return { type: 'four_2', p: m.p, len: 6 };
    return null;
}

/** --- 强化 AI 与 游戏流程 --- **/
function initGame() {
    let deck = [];
    for(let v in POWER) {
        if(v==='S'||v==='B') deck.push({v, p:POWER[v], s:'*', c:v==='B'?'red':'black'});
        else ['H','D','S','C'].forEach(s => deck.push({v, p:POWER[v], s, c:(s==='H'||s==='D'?'red':'black')}));
    }
    deck.sort(() => Math.random() - 0.5);
    G.hands = [deck.slice(0, 27).sort((a,b)=>b.p-a.p), deck.slice(27, 54).sort((a,b)=>b.p-a.p)];
    G.last = null; G.turn = 0; G.selected.clear();
    renderAll(); resetTimer();
}

function aiPlay() {
    const hand = G.hands[1]; let toPlay = [];
    if(!G.last || G.last.player === 1) {
        // 主动出牌逻辑
        toPlay = findBest(hand);
    } else {
        // 被动压牌
        let l = getInfo(G.last.cards);
        let matches = [];
        for(let n=1; n<=12; n++){
            for(let i=0; i<=hand.length-n; i++){
                let sub = hand.slice(i, i+n); let info = getInfo(sub);
                if(info && (info.type===l.type || info.type==='bomb') && (info.len===l.len || info.type==='bomb')){
                    if(info.type==='bomb' && l.type!=='bomb') matches.push(sub);
                    else if(info.p > l.p) matches.push(sub);
                }
            }
        }
        if(matches.length) toPlay = matches.sort((a,b)=>getInfo(a).p - getInfo(b).p)[0];
    }
    if(toPlay.length) execute(toPlay); else handlePass();
}

function findBest(hand) {
    for(let l=12; l>=5; l--) { // 搜长顺子
        let u = [...new Set(hand.map(c=>c.p))].filter(p=>p<15).sort((a,b)=>a-b);
        for(let i=0; i<=u.length-l; i++){
            let sub = u.slice(i, i+l);
            if(sub[l-1]-sub[0] === l-1) return sub.map(p=>hand.find(c=>c.p===p));
        }
    }
    return [hand[hand.length-1]];
}

function execute(cards) {
    let info = getInfo(cards);
    G.hands[G.turn] = G.hands[G.turn].filter(c => !cards.includes(c));
    G.last = { player: G.turn, cards };
    if(info.type === 'bomb') {
        playSound('bomb'); document.body.classList.add('glitch-bg'); document.getElementById('desk').classList.add('bomb-effect');
        setTimeout(() => { document.body.classList.remove('glitch-bg'); document.getElementById('desk').classList.remove('bomb-effect'); }, 600);
    } else { playSound('play'); }
    document.getElementById(`desk-${G.turn}`).innerHTML = renderCards(cards);
    if(G.hands[G.turn].length === 0) { alert(G.turn===0?"YOU WIN":"CPU WIN"); initGame(); return; }
    G.selected.clear(); G.turn = 1 - G.turn;
    document.getElementById(`desk-${G.turn}`).innerHTML = "";
    renderAll(); resetTimer();
    if(G.turn === 1) setTimeout(aiPlay, 800);
}

function handlePlay() {
    let cards = Array.from(G.selected).map(i => G.hands[0][i]);
    let info = getInfo(cards);
    if(!info) return;
    if(G.last && G.last.player !== 0) {
        let l = getInfo(G.last.cards);
        if(info.type==='bomb'){ if(l.type==='bomb' && info.weight<=l.weight) return; }
        else { if(info.type!==l.type || info.len!==l.len || info.p<=l.p) return; }
    }
    execute(cards);
}

function handlePass() {
    if(!G.last || G.last.player === G.turn) return;
    document.getElementById(`desk-${G.turn}`).innerHTML = "<div style='color:#444'>SKIP</div>";
    G.turn = 1 - G.turn; document.getElementById(`desk-${G.turn}`).innerHTML = "";
    renderAll(); resetTimer();
    if(G.turn === 1) setTimeout(aiPlay, 800);
}

function resetTimer() {
    clearInterval(G.timerInt); G.timeLeft = 30;
    const el = document.getElementById('timer'); el.classList.remove('critical');
    G.timerInt = setInterval(() => {
        G.timeLeft--; el.innerText = G.timeLeft;
        if(G.timeLeft < 7) el.classList.add('critical');
        if(G.timeLeft <= 0) G.turn === 0 ? handlePass() : aiPlay();
    }, 1000);
}

function renderAll() {
    document.getElementById('comp-count').innerText = G.hands[1].length;
    document.getElementById('hand-1').innerHTML = G.hands[1].map(() => `<div class="card back" style="margin-left:-60px"></div>`).join('');
    const h0 = document.getElementById('hand-0'); h0.innerHTML = "";
    G.hands[0].forEach((c, i) => {
        const deg = (Math.random()*8-4).toFixed(1); const offY = (Math.random()*12-6).toFixed(1);
        const div = document.createElement('div');
        div.className = `card ${c.c} ${G.selected.has(i)?'selected':''}`;
        div.style.transform = `rotate(${deg}deg)`; div.style.top = `${offY}px`;
        div.innerHTML = `<span class="v">${c.v}</span><span style="font-size:10px; align-self:flex-end;">${c.s}</span>`;
        div.onclick = () => { playSound('select'); G.selected.has(i)?G.selected.delete(i):G.selected.add(i); renderAll(); };
        h0.appendChild(div);
    });
    document.getElementById('ui').className = G.turn === 0 ? 'controls active' : 'controls';
}

function renderCards(cards) { return cards.map(c => `<div class="card ${c.c}" style="margin-left:-50px; transform:scale(0.9); cursor:default"><span class="v">${c.v}</span><span>${c.s}</span></div>`).join(''); }

initGame();
</script>
</body>
</html>
